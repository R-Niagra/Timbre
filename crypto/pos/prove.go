package pos

import (
	"fmt"
	"math/big"

	"github.com/Nik-U/pbc"
	pb "github.com/guyu96/go-timbre/protobuf"
	// "github.com/mbilal92/pbc"
)

// Proof is the storage proof generated by the storage provider
type Proof struct {
	psi *pbc.Element
	y   *pbc.Element
	tag *pbc.Element
}

// Prove generates and returns a storage proof for message M in response to the challenge ch issued by a verifier.
func Prove(M []byte, cfg *Config, pairing *pbc.Pairing, pk *PublicKey, tags AuthTags, ch *Chall) *Proof {
	r, rho, I := ch.r, ch.rho, ch.I
	// Compute v[i] = rho^I[i]
	v := make([]*pbc.Element, len(I))
	for i := range v {
		exp := big.NewInt(int64(I[i]))
		v[i] = pairing.NewZr().Set(rho).ThenPowBig(exp)
	}
	// Compute authentication tag as a product of tag[i]^vi, i in I
	tag := pairing.NewG1().Set1()
	for i, vi := range v {
		idx := I[i] - 1 // make idx 0-indexed
		term := pairing.NewG1().Set(tags[idx]).ThenPowZn(vi)
		tag.ThenMul(term)
	}
	// Compute the coefficient vector A, A[j] = sum_i(v[i]*mij)
	blocks := Process(M, cfg)
	A := make([]*pbc.Element, cfg.s)
	for j := 0; j < cfg.s; j++ {
		A[j] = pairing.NewZr().Set0()
		for i, vi := range v {
			mij := new(big.Int).SetBytes(blocks[I[i]-1][j]) // the subscript i = I[i] - 1
			term := pairing.NewZr().Set(vi).ThenMulBig(mij)
			A[j].ThenAdd(term)
		}
	}
	// Compute the quotient polynomial (P[A] - P[A](r)) / (x - r)
	y := polyEval(A, r, pairing)           // P[A](r)
	A[0].ThenSub(y)                        // P[A] - P[A](r)
	w, remainder := polyDiv(A, r, pairing) // quotient vector w and remainder
	if !remainder.Is0() {
		panic("Non-zero remainder for polynomial division.")
	}
	// Compute psi = product_i( ((g^a)^i)^wi )
	psi := pairing.NewG1().Set1()
	for i, gai := range pk.gaPow {
		wi := pairing.NewZr()
		// w should have length s-1 since it is A divided by a linear polynomial
		if i < len(w) { // if w has not yet been exhausted
			wi.Set(w[i])
		} else { // set wi to 0 if wi has been exhausted
			wi.Set0()
		}
		term := pairing.NewG1().Set(gai).ThenPowZn(wi)
		psi.ThenMul(term)
	}

	return &Proof{
		psi: psi,
		y:   y,
		tag: tag,
	}
}

// polyEval evaluates the polynomial specified by the coefficient vector at the given point using Horner's rule and returns the result. By convention, coefficient vectors are sorted in ascending order of power. All coefficients are in Zp (Zr in libpbc).
func polyEval(poly []*pbc.Element, point *pbc.Element, pairing *pbc.Pairing) *pbc.Element {
	l := len(poly)
	if l == 0 {
		return pairing.NewZr().Set0()
	}
	// Start with the coefficient of the highest power
	res := pairing.NewZr().Set(poly[l-1])
	for i := l - 2; i >= 0; i-- {
		res.ThenMul(point).ThenAdd(poly[i])
	}
	return res
}

// polyDiv divides the polynomial specified by the coefficient vector by the monic linear polynomial (x - point) using synthetic division. It returns the coefficient vector for the quotient and a remainder of degree at most 0. By convention, coefficient vectors are sorted in ascending order of power. All coefficients are in Zp (Zr in libpbc).
func polyDiv(dividend []*pbc.Element, point *pbc.Element, pairing *pbc.Pairing) ([]*pbc.Element, *pbc.Element) {
	// Initialize the remainder to be the dividend
	l := len(dividend)
	remainder := make([]*pbc.Element, l)
	for i := range remainder {
		remainder[i] = pairing.NewZr().Set(dividend[i])
	}
	// Perform synthetic division, starting with the coefficient of the second highest power
	for i := l - 2; i >= 0; i-- {
		term := pairing.NewZr().Set(remainder[i+1]).ThenMul(point)
		remainder[i].ThenAdd(term)
	}
	if l == 0 { // 0 polynomial
		return nil, pairing.NewZr().Set0()
	}
	if l == 1 { // constant polynomial
		return nil, remainder[0]
	}
	// Polynomial of degree at least 1
	return remainder[1:], remainder[0]
}

func (prf *Proof) String() string {
	return fmt.Sprintf("Proof:\n\tpsi: %s \t \ty: %s \ttag: %s\n", prf.psi, prf.y, prf.tag)
}

// ToProto converts Proof struct to Proof protobuf struct.
func (prf *Proof) ToProto() *pb.Proof {
	return &pb.Proof{
		// Psi: prf.psi.CompressedBytes(),
		Psi: prf.psi.Bytes(),
		Y:   prf.y.Bytes(),
		Tag: prf.tag.Bytes(),
	}
}

// FromProto sets Proof based on Proof protobuf struct.
func (prf *Proof) FromProto(pbPrf *pb.Proof, pairing *pbc.Pairing) {
	// prf.psi = pairing.NewG1().SetCompressedBytes(pbPrf.Psi)
	prf.psi = pairing.NewG1().SetBytes(pbPrf.Psi)
	prf.y = pairing.NewZr().SetBytes(pbPrf.Y)
	prf.tag = pairing.NewG1().SetBytes(pbPrf.Tag)
}

// Equals checks if two proofs are the same.
func (prf *Proof) Equals(anotherPrf *Proof) bool {
	return prf.psi.Equals(anotherPrf.psi) && prf.y.Equals(anotherPrf.y) && prf.tag.Equals(anotherPrf.tag)
}

// Is0 checks if any element of prf is 0.
func (prf *Proof) Is0() bool {
	return prf.psi.Is0() || prf.y.Is0() || prf.tag.Is0()
}

func (prf *Proof) PsiIs0() bool {
	return prf.psi.Is0()
}

func (prf *Proof) YIs0() bool {
	return prf.y.Is0()
}

func (prf *Proof) TagIs0() bool {
	return prf.tag.Is0()
}

//GetRandProof returns the random pairing
func GetRandProof(pairing *pbc.Pairing) *Proof {
	return &Proof{
		psi: pairing.NewG1().Rand(),
		y:   pairing.NewZr().Rand(),
		tag: pairing.NewG1().Rand(),
	}

}

//GetRandProof returns the random pairing
func GetProofwith0(pairing *pbc.Pairing) *Proof {
	return &Proof{
		psi: pairing.NewG1().Set0(),
		y:   pairing.NewZr().Set0(),
		tag: pairing.NewG1().Set0(),
	}

}
